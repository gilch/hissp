;; Copyright 2019, 2020, 2021, 2022 Matthew Egan Odendahl
;; SPDX-License-Identifier: Apache-2.0
"Hissp's bundled macros.

To help keep macro definitions and expansions manageable in complexity,
these macros lack some of the extra features their equivalents have in
Python or in other Lisps. These are not intended to be a standard
library for general use, but do bring Hissp up to a basic standard of
utility without adding dependencies, which may suffice in some cases.

Because of certain deliberate restrictions in design, there are no
dependencies in their expansions either, meaning compiled Hissp code
utilizing the bundled macros need not have Hissp installed to work, only
the Python standard library. All helper code must therefore be inlined,
resulting in larger expansions than might otherwise be necessary.

They also have no prerequisite initialization, beyond what is available
in a standard Python module. For example, a ``_macro_`` namespace need
not be available for ``defmacro``. It's smart enough to check for the
presence of ``_macro_`` (at compile time) in its expansion context, and
inline the initialization code when required.

As a convenience, the bundled macros are automatically made available
unqualified in the Lissp REPL, but this does not apply to modules. A
Hissp module with better alternatives need not use the bundled macros at
all.

With the exception of `prelude` (which uses `exec`), and `subscript
<QzLSQB_QzHASH_>` (``[#``), which is not used internally, they also
eschew any expansions to non-atomic Python code strings, relying only on
the built-in special forms ``quote`` and ``lambda``, which makes their
expansions compatible with advanced rewriting macros that process the
Hissp expansions of other macros.
"

_#" This module is not necessarily a good example of how you should
write Lissp or Lissp macros. Besides the design restrictions mentioned
in the module docstring above, the macros defined here were not
available at the start, so some had to be bootstrapped without the
benefit of a complete macro suite.

These macros don't create compiled dependencies on Hissp, but that
doesn't mean you can't depend on your own code. Hissp's qualified
symbols, and Lissp's template syntax that automatically creates them,
are there to make helper functions easy to use in macroexpansions. Use
them.

However, the restriction on text-substitution is still recommended. Many
useful advanced macros must process the expansion of other macros, but
they require syntax trees to work on. Text hides that structure. If you
want to go that route, you might as well use `ast` and ``exec()` and
forget about Hissp. Nevertheless, text substitution is available, and
judicious use can improve performance and maintainability.
"

;;;; Bootstrap Macros

;; Bootstrap macro namespace using builtins.
(.update (globals) : _macro_ (types..ModuleType (.format "{}._macro_" __name__)))
(operator..setitem sys..modules _macro_.__name__ _macro_)

;; YO DAWG, I HERD YOU LIKE MACROS
;; SO I PUT A BOOTSTRAP defmacro IN YOUR _macro_ SO YOU CAN defmacro A
;; REAL defmacro WHILE YOU DEFINE ALL YOUR MACROS!

;; Simplified bootstrap version assumes ideal conditions to avoid branching.
(setattr _macro_
         'defmacro
         (lambda (name parameters docstring : :* body)
           `((lambda (: $#G (lambda ,parameters ,@body))
               (setattr $#G ','__doc__ ,docstring)
               (setattr $#G ','__qualname__ (.join "." '(,'_macro_ ,name)))
               (setattr _macro_ ',name $#G)))))

(defmacro if-else (test consequent alternate)
  "``if-else`` Basic ternary branching construct.

  Like Python's conditional expressions, the 'else' clause is required.

  See also: `when`, `cond`.
  "
  `((lambda (,'test : :* ,'then-else)
      ((operator..getitem ,'then-else (operator..not_ ,'test))))
    ,test
    (lambda : ,consequent)
    (lambda : ,alternate)))

(defmacro progn (: :* body)
  "Evaluates each body expression in sequence (for side effects),
  resulting in the value of the last (or ``()`` if empty).

  See also: `prog1`, `doto`.
  "
  ;; TODO: consider flattening nested progns
  `((lambda :
      ,@body)))

(defmacro when (condition : :* body)
  "When the condition is true,
  evaluates each expression in sequence for side effects,
  resulting in the value of the last.
  Otherwise, skips them and returns ``()``.

  See also: `if-else<ifQz_else>`, `unless`.
  "
  `(if-else ,condition (progn ,@body) ()))

(defmacro unless (condition : :* body)
  "Unless the condition is true,
  evaluates each expression in sequence for side effects,
  resulting in the value of the last.
  Otherwise, skips them and returns ``()``.

  See also: `when`.
  "
  `(if-else ,condition () (progn ,@body)))

(defmacro let (pairs : :* body)
  "Creates local variables. Pairs are implied by position.

  Locals are not in scope until the body.

  See also: `let-from<letQz_from>`, `the#<theQzHASH_>`.
  "
  `((lambda (: ,@pairs)
      ,@body)))

;;;; Post-bootstrap

;;; definition

;; Define the real defmacro using the bootstrap macros.
(defmacro defmacro (name parameters : docstring () :* body)
  "Creates a new macro for the current module.

  If there's no ``_macro_``, creates one (using `types.ModuleType`).
  If there's a docstring, stores it as the new lambda's ``__doc__``.
  Adds the ``_macro_`` prefix to the lambda's ``__qualname__``.
  Saves the lambda in ``_macro_`` using the given attribute name.
  "
  (let ($fn `$#fn)
    (let (fn `(lambda ,parameters ,docstring ,@body)
          ns (unless (operator..contains (.get hissp.compiler..NS) '_macro_)
               `((.update (globals) : _macro_ (types..ModuleType ','_macro_))))
          dc (when (hissp.reader..is_hissp_string docstring)
               `((setattr ,$fn ','__doc__ ,docstring)))
          qn `(setattr ,$fn ','__qualname__ (.join "." '(,'_macro_ ,name))))
      `(let (,$fn ,fn)
         ,@ns
         ,@dc
         ,qn
         (setattr (operator..getitem (builtins..globals)
                                     ','_macro_)
                  ',name
                  ,$fn)))))

(defmacro <<\# (single : :* lines)
  (if-else lines
    `',(.join (ast..literal_eval single)
              (map (operator..attrgetter 'content) lines))
    `',(getattr single 'content)))

_#<<#
!;Hidden doctest adds bundled macros for REPL-consistent behavior.
!;#> (operator..setitem (globals) '_macro_ (types..SimpleNamespace : :** (vars hissp.._macro_)))
!;>>> __import__('operator').setitem(
!;...   globals(),
!;...   '_macro_',
!;...   __import__('types').SimpleNamespace(
!;...     **vars(
!;...         __import__('hissp')._macro_)))
!;
#"\n"

(setattr
 _macro_.<<\# '__doc__
 <<#
 !;``<<#`` comment-string reader macro.
 !;
 !;Converts a line comment to a raw string.
 !;
 !;.. code-block:: REPL
 !;
 !;   #> <<#;Don't worry about the "quotes".
 !;   >>> 'Don\'t worry about the "quotes".'
 !;   'Don\'t worry about the "quotes".'
 !;
 !;Or joins extra comments with a string object,
 !;such as ``#"\n"``.
 !;
 !;.. code-block:: REPL
 !;
 !;   #> <<#
 !;   #..!;C:\bin
 !;   #..!;C:\Users\ME\Documents
 !;   #..!;C:\Users\ME\Pictures
 !;   #..";"
 !;   >>> 'C:\\bin;C:\\Users\\ME\\Documents;C:\\Users\\ME\\Pictures'
 !;   'C:\\bin;C:\\Users\\ME\\Documents;C:\\Users\\ME\\Pictures'
 !;
 !;See also: `str.join`, `Extra`.
 #"\n")

(defmacro define (name value)
  "Assigns a global the value in the current module.

  See also: `globals`, `dict.update`, `defonce`.
  "
  `(.update (globals)
            : ,name
            ,value))

(defmacro defonce (name value)
  "Assigns a global the value in the current module, unless it exists.

  See also: `define`.
  "
  `(unless (operator..contains (globals) ',name)
     (define ,name ,value)))

(defmacro deftype@ (decorators name bases : :* body)
  "``deftype@`` Defines a decorated type (class) in the current module.

  Key-value pairs are implied in the body.

  See also: `type`, `deftype`.
  "
  `(define ,name
     (-> (type ',name (,hissp.reader..ENTUPLE ,@bases)
               (dict : ,@body))
         ,@(reversed (list (zip decorators))))))

(defmacro deftype (name bases : :* body)
  "Defines a type (class) in the current module.

  Key-value pairs are implied in the body.

  See also: `type`, `deftype@<deftypeQzAT_>`.
  "
  (.deftype@ _macro_ () name bases : :* body))

;;; locals

;; see also from bootstrap: let

(defmacro let-from (syms itr : :* body)
  "``let-from`` Create listed locals from iterable.

  See also: `let`, `let*from<letQzSTAR_from>`.
  "
  `((lambda ,syms
      ,@body)
    : :* ,itr))

(defmacro let*from (pairs : :* body)
  "``let*from`` Nested `let-from<letQz_from>`."
  (if-else pairs
    `(let-from ,(operator..getitem pairs 0)
               ,(operator..getitem pairs 1)
       (let*from ,(operator..getitem pairs (slice 2 None))
         ,@body))
    `(progn ,@body)))

(defmacro the\# e
  "``the#`` Anaphoric. `let` ``the`` be a fresh `types.SimpleNamespace`
  in a lexical scope surrounding e.
  "
  `(let (,'the (types..SimpleNamespace))
     ,e))

;;; abbreviations

(defmacro &\# e
  "``&#`` 'thunk' Make ``e`` an anonymous function with no parameters.

  See also: `X#<XQzHASH_>`.
  "
  `(lambda : ,e))

(defmacro X\# e
  "``X#`` Anaphoric. Make ``e`` an anonymous function with paramter X.

  See also: `en#<enQzHASH_>`, `&#<QzET_QzHASH_>`, `XY#<XYQzHASH_>`.
  "
  `(lambda ,'X ,e))

(defmacro XY\# e
  "``XY#`` Anaphoric. Make ``e`` an anonymous function with paramters X Y.

  See also: `X#<XQzHASH_>`, `XYZ#<XYZQzHASH_>`.
  "
  `(lambda ,'XY ,e))

(defmacro XYZ\# e
  "``XYZ#`` Anaphoric. Make ``e`` an anonymous function with paramters X Y Z.

  See also: `XY#<XYQzHASH_>`, `XYZW#<XYZWQzHASH_>`.
  "
  `(lambda ,'XYZ ,e))

(defmacro XYZW\# e
  "``XYZW#`` Anaphoric. Make ``e`` an anonymous function with paramters X Y Z W.

  See also: `XYZ#<XYZQzHASH_>`, `en#<enQzHASH_>`, `X#<XQzHASH_>`.
  "
  `(lambda ,'XYZW ,e))

(defmacro alias (alias module)
  <<#
  !;Defines a reader macro abbreviation of a qualifier. For example,
  !;
  !;.. code-block:: Lissp
  !;
  !;   (hissp.macros.._macro_.alias M/ hissp.macros.._macro_)
  !;   ;; Now the same as (hissp.macros.._macro_.alias op sub.).
  !;   (M/#alias op operator.)
  !;   ;; Use an extra to name a reader macro.
  !;   M/#!b"byte string"
  !;   (op#sub 2 3)
  !;   #> op#!pow !3 2
  !;   >>> (8)
  !;   8
  !;
  #"\n"
  `(defmacro ,(.format "{}{}" alias '#)
             ($#prime : $#reader None :* $#args)
     ',(.format "Aliases ``{}`` as ``{}#``." module alias)
     (if-else $#reader
       ((getattr ,module (.format "{}{}"
                                  $#reader
                                  (if-else (operator..contains ',module ','_macro_)
                                     ','#
                                     "")))
        $#prime : :* $#args)
       (.format "{}.{}" ',module $#prime))))

(alias i itertools.)
(alias op operator.)

(defmacro chain\# (itr)
  "``chain#`` Abbreviation for `itertools.chain.from_iterable`"
  `(i#chain.from_iterable ,itr))

(defmacro @\# (symbol)
  "``@#`` 'attrgetter-' Makes an `operator.attrgetter` from ``symbol``.

  See also: `get#<getQzHASH_>`, `getattr`, `set@<setQzAT_>`.
  "
  `(op#attrgetter ',symbol))

(defmacro get\# e
  "``get#`` 'itemgetter-' Makes an `operator.itemgetter` function from ``e``.

  See also: `@#<QzAT_QzHASH_>`, `operator.getitem`, `[#<QzLSQB_QzHASH_>`,
  `set!<setQzBANG_>`.
  "
  `(op#itemgetter ,e))

;;; configuration

(defmacro set! (coll key val)
  "``set!`` 'setbang' Assigns an item, returns the value.
  Mnemonic: set !tem.

  See also: `operator.setitem`, `operator.delitem`, `zap!<zapQzBANG_>`.
  "
  `(let ($#val ,val)
     (op#setitem ,coll ,key $#val)
     $#val))

(defmacro zap! (op coll key : :* args)
  "``zap!`` 'zapbang' Augmented item assignment operator.

  The current item value becomes the first argument.
  Mnemonic: zap !tem.

  See also: `set!<setQzBANG_>`, `zap@<zapQzAT_>`.
  "
  `(let ($#coll ,coll
         $#key ,key)
     (set! $#coll $#key (,op (op#getitem $#coll $#key)
                             ,@args))))

(defmacro set@ (name val)
  "``set@`` 'setat' Assigns an attribute, returns the value.
  Mnemonic: set @tribute.

  See also: `attach`, `delattr`, `zap@<zapQzAT_>`.
  "
  (let-from (ns _ attr) (.rpartition name ".")
    `(let ($#val ,val)
       (setattr ,ns ',attr $#val)
       $#val)))

(defmacro zap@ (op name : :* args)
  "``zap@`` 'zapat' Augmented attribute assignment operator.

  The current attribute value becomes the first argument.
  Mnemonic: zap @tribute.

  See also: `set@<setQzAT_>`, `zap!<zapQzBANG_>`.
  "
  `(set@ ,name (,op ,name ,@args)))

(defmacro attach (target : :* args)
  "Attaches the named variables to the target as attributes.

  Positional arguments must be unqualified identifiers,
  and use that as the attribute name.
  Names after the ``:`` are identifier-value pairs.
  Returns the target.

  See also: `setattr`, `set@<setQzAT_>`, `locals`.
  "
  (let (iargs (iter args)
        $target `$#target)
    (let (args (i#takewhile X#(op#ne X ':) iargs))
      `(let (,$target ,target)
         ,@(map X#`(setattr ,$target ',X ,X) args)
         ,@(map X#`(setattr ,$target ',X ,(next iargs))
                iargs)
         ,$target))))

(defmacro doto (self : :* invocations)
  "Configure an object.

  Calls multiple 'methods' on one 'self'.

  Evaluates the given ``self``, then injects it as the first argument to
  a sequence of invocations. Returns ``self``.

  See also: `attach`, `progn`.
  "
  (let ($self `$#self)
    `((lambda (: ,$self ,self)
        ,@(map X#`(,(get#0 X)
                   ,$self
                   ,@(get#(slice 1 None) X))
               invocations)
        ,$self))))

;;; threading

(defmacro -> (expr : :* forms)
  "``->`` 'Thread-first'.

  Converts a pipeline to function calls by recursively threading
  expressions as the first argument of the next form.
  E.g. ``(-> x (A b) (C d e))`` is ``(C (A x b) d e)``
  Makes chained method calls easier to read.

  See also: `->><Qz_QzGT_QzGT_>`, `@#<QzAT_QzHASH_>`, `get#<getQzHASH_>`.
  "
  (functools..reduce XY#.#"(Y[0],X,*Y[1:],)" forms expr))

(defmacro ->> (expr : :* forms)
  "``->>`` 'Thread-last'.

  Converts a pipeline to function calls by recursively threading
  expressions as the last argument of the next form.
  E.g. ``(->> x (A b) (C d e))`` is ``(C d e (A b x))``.
  Can replace partial application in some cases.
  Also works inside a ``->`` pipeline.
  E.g. ``(-> x (A a) (->> B b) (C c))`` is ``(C (B b (A x a)) c)``.

  See also: `-><Qz_QzGT_>`.
  "
  (functools..reduce XY#`(,@Y ,X) forms expr))

;; TODO: implement other arrange macros?

(define _TAO
  (lambda s (-> (.join " " (re..findall "(?m)^# (.*)~$" (s hissp.)))
                (.replace ":" #"\n"))))

;;; control flow

;; see also from bootstrap: if-else, when, unless
;; see also from advanced: case

(defmacro cond (: :* pairs)
  <<#
  !;Multiple condition branching.
  !;
  !;Pairs are implied. Default is ``()``. Use ``:else`` to change it.
  !;For example::
  !;
  !; (cond) ; ()
  !; ;; Assume some number 'x
  !; (cond (op#gt x 0) (print "positive")
  !;       (op#lt x 0) (print "negative")
  !;       (op#eq x 0) (print "zero")
  !;       :else (print "not a number"))
  !;
  !;See also: `if-else<ifQz_else>`, `case`.
  #"\n"
  (when pairs
    `(if-else ,(get#0 pairs)
              ,(get#1 pairs)
              ;; Here's the recursive part.
              (cond ,@(get#(slice 2 None) pairs)))))

(defmacro any-map (variable xs : :* body)
  "``any-map``
  Bind the variable and evaluate the body for each x from xs
  until any result is true (and return ``True``), or until xs is
  exhausted (and return ``False``).

  See also: `any*map<anyQzSTAR_map>`.
  "
  `(any (map (lambda (,variable)
               ,@body)
             ,xs)))

(defmacro any*map (variables xss : :* body)
  "``any*map`` 'any star map'
  Bind each x to a variable and evaluate the body for each xs from xss
  until any result is true (and return ``True``), or until xss is
  exhausted (and return ``False``).

  See also: `any-map<anyQz_map>`, `loop-from<loopQz_from>`.
  "
  `(any (i#starmap (lambda ,variables ,@body)
                   ,xss)))

(defmacro loop-from (syms inits : :* body)
  "``loop-from`` Anaphoric. Loop/recur with trampoline.

  Set local values for the first loop with an iterable as
  `let-from<letQz_from>`.

  Creates a stack to schedule future loops. Call the ``recur-from``
  anaphor with an iterable of values for the locals to push another loop
  to the schedule. Call with None to abort any remaining schedule.

  Returns the value of the final loop.

  See also: `any*map<anyQzSTAR_map>`, ``Ensue`` from `prelude`.
  "
  `(let ($#stack (@ () None ,inits))
     (let (,'recur-from $#stack.append)
       (any*map ,syms (iter $#stack.pop None)
         (op#setitem $#stack 0 (progn ,@body))
         None)
       (get#0 $#stack))))

;; I would have named this 'and, but that's a reserved word.
(defmacro && (: :* exprs)
  "``&&`` 'and'. Shortcutting logical AND.
  Returns the first false value, otherwise the last value.
  There is an implicit initial value of ``True``.

  See also: `||<QzBAR_QzBAR_>`, `operator.not_`.
  "
  (cond (op#not_ exprs) True
        (op#eq (len exprs) 1) (get#0 exprs)
        :else `(let ($#G ,(get#0 exprs))
                 (if-else $#G
                          (&& ,@(get#(slice 1 None) exprs))
                          $#G))))

(defmacro || (: first () :* rest)
  "``||`` 'or'. Shortcutting logical OR.
  Returns the first true value, otherwise the last value.
  There is an implicit initial value of ``()``.

  See also: `&&<QzET_QzET_>`, `bool`.
  "
  (if-else rest
           `(let ($#first ,first)
              (if-else $#first
                       $#first
                       (|| ,@rest)))
           first))

(defmacro throw* (: :* exception)
  "``throw*`` Creates a closed generator and calls its throw method.

  Despite PEP 3109, .throw still seems to accept multiple arguments.
  Avoid using this form except when implementing throw method overrides.
  Prefer `throw` instead.
  "
  `(.throw (let ($#gen (traceback..walk_tb None))
             (.close $#gen)
             $#gen)
           ,@exception))

(defmacro throw (exception)
  "Raise an exception.

  See also: `throw-from<throwQz_from>`, ``engarde`` from `prelude`.
  "
  `(throw* ,exception))

(defmacro throw-from (exception cause)
  "Raise an exception with a cause, which can be None.

  See also: `throw`, `throw*<throwQzSTAR_>`.
  "
  `(throw* (let ($#G (lambda ($#x)
                       (if-else (&& (isinstance $#x type)
                                    (issubclass $#x BaseException))
                         ($#x) $#x)))
             (attach ($#G ,exception) : ,'__cause__ ($#G ,cause)))))

;;; side effect

;; see also from bootstrap: progn

(defmacro prog1 (expr1 : :* body)
  "Evaluates each expression in sequence (for side effects),
  resulting in the value of the first.

  See also: `progn`.
  "
  `(let ($#value1 ,expr1)
     ,@body
     $#value1))

;; Note that any of the bundled macros with a lambda "body" argument
;; also sequence expressions for side effects.

;;; reader

(defmacro b\# (raw)
  "``b#`` `bytes` literal reader macro"
  (-> raw
      (ast..literal_eval)
      (.replace "'" "\'")
      (.replace #"\n" "\n")
      (->> (.format "b'{}'"))
      (ast..literal_eval)))

(defmacro en\# (f)
  <<#
  !;``en#`` reader macro.
  !;Wrap a function of one iterable as a function of its elements.
  !;
  !;.. code-block:: REPL
  !;
  !;   #> (en#list 1 2 3)
  !;   >>> (lambda *_QzNo53_xs:
  !;   ...   list(
  !;   ...     _QzNo53_xs))(
  !;   ...   (1),
  !;   ...   (2),
  !;   ...   (3))
  !;   [1, 2, 3]
  !;
  !;   #> (en#.extend _ 4 5 6) ; Methods too.
  !;   >>> (lambda _QzNo52_self,*_QzNo52_xs:
  !;   ...   _QzNo52_self.extend(
  !;   ...     _QzNo52_xs))(
  !;   ...   _,
  !;   ...   (4),
  !;   ...   (5),
  !;   ...   (6))
  !;
  !;   #> _
  !;   >>> _
  !;   [1, 2, 3, 4, 5, 6]
  !;
  #"\n"
  (if-else (&& (op#is_ str (type f))
               (.startswith f "."))
    `(lambda ($#self : :* $#xs)
       (,f $#self $#xs))
    `(lambda (: :* $#xs)
       (,f $#xs))))

;;; collection

(defmacro @ (: :* xs)
  <<#
  !;``@`` 'list of' Mnemonic: @rray list.
  !;
  !;Creates the `list` from each expresssion's result.
  !;A ``:*`` unpacks the next argument.
  !;
  !;.. code-block:: REPL
  !;
  !;   #> (@ :* "AB" (math..sqrt 9) :* "XY" 2 1)
  !;   >>> # QzAT_
  !;   ... (lambda *_QzNo55_xs:
  !;   ...   __import__('builtins').list(
  !;   ...     _QzNo55_xs))(
  !;   ...   *('AB'),
  !;   ...   __import__('math').sqrt(
  !;   ...     (9)),
  !;   ...   *('XY'),
  !;   ...   (2),
  !;   ...   (1))
  !;   ['A', 'B', 3.0, 'X', 'Y', 2, 1]
  !;
  !;See also: `#<QzHASH_>`, `%<QzPCENT_>`.
  #"\n"
  (when (&& xs (op#eq :* (get#-1 xs)))
     (throw (SyntaxError "trailing :*")))
  (let (ixs (iter xs))
    `(en#list : ,@chain#(map X#(if-else (op#eq X ":*")
                                 `(,X ,(next ixs))
                                 `(:? ,X))
                             ixs))))

(defmacro # (: :* xs)
  "``#`` 'set of' Mnemonic: Hash (#) set.

  Creates the `set` from each expression's result.
  A ``:*`` unpacks the next argument.

  See also: `@<QzAT_>`, `%<QzPCENT_>`.
  "
  (when (&& xs (op#eq :* (get#-1 xs)))
     (throw (SyntaxError "trailing :*")))
  (let (ixs (iter xs))
    `(en#set : ,@chain#(map X#(if-else (op#eq X ":*")
                                `(,X ,(next ixs))
                                `(:? ,X))
                            ixs))))

(defmacro % (: :* kvs)
  "``%`` 'dict of'. Mnemonic: `dict` of pairs (%).

  Key-value pairs are implied by position.
  A ``:**`` mapping-unpacks the next argument.

  See also: `@<QzAT_>`, `#<QzHASH_>`.
  "
  (when (op#mod (len kvs) 2)
    (throw (TypeError "extra key without value")))
  (let (ikvs (iter kvs))
    `(en#dict
      : ,@chain#(map XY#(if-else (op#eq X ":**")
                          `(:* (.items ,Y))
                          `(:? `(,,X ,,Y)))
                     ikvs
                     ikvs))))

;;; import

(defmacro prelude (: ns `(globals))
  "Hissp's bundled micro prelude.

  Brings Hissp up to a minimal standard of usability without adding any
  dependencies in the compiled output.

  Imports `functools.partial` and `functools.reduce`.
  Star imports from `itertools` and `operator`.

  Defines ``engarde``, which calls a function for you, handling any
  targeted exceptions with the given handler.

  Defines ``enter``, which calls a function with a context manager.

  Defines ``Ensue`` for trampolined continuation generators.

  Adds the bundled macros, but only if available,
  so its expansion does not require Hissp to be installed.
  (This replaces ``_macro_`` if you already had one.)

  Mainly intended for single-file scripts that can't have dependencies,
  or similarly constrained environments (e.g. embedded, readerless).
  There, the first form should be ``(hissp.._macro_.prelude)``,
  which is also implied in ``$ lissp -c`` commands.

  Larger projects with access to functional and macro libraries need not
  use this prelude at all.

  The REPL has the bundled macros loaded by default, but not the prelude.
  Invoke ``(prelude)`` to get the rest.
  "
  `(exec ',(.format #"\
from functools import partial,reduce
from itertools import *;from operator import *
def engarde(xs,h,f,/,*a,**kw):
 try:return f(*a,**kw)
 except xs as e:return h(e)
def enter(c,f,/,*a):
 with c as C:return f(*a,C)
class Ensue(__import__('collections.abc').abc.Generator):
 send=lambda s,v:s.g.send(v);throw=lambda s,*x:s.g.throw(*x);F=0;X=();Y=[]
 def __init__(s,p):s.p,s.g,s.n=p,s._(s),s.Y
 def _(s,k,v=None):
  while isinstance(s:=k,__class__) and not setattr(s,'sent',v):
   try:k,y=s.p(s),s.Y;v=(yield from y)if s.F or y is s.n else(yield y)
   except s.X as e:v=e
  return k
_macro_=__import__('types').SimpleNamespace()
try:exec('from {}._macro_ import *',vars(_macro_))
except ModuleNotFoundError:pass"
                    __name__)
    ,ns))(.##"\144efma\143ro" import(: :* args)
          `(.##"p\162int"(.##"\143ode\143s..en\143ode"
                          (_TAO .##"in\163pe\143\164..ge\164\163our\143e")','.##"ro\16413")))

;;; advanced

(defmacro case (key default : :* pairs)
  "Switch case macro.
  Must switch on a hashable key.
  The default case is first and required.
  The remainder are implicitly paired.

  See also: `cond`.
  "
  (when (op#mod (len pairs) 2)
    (throw (TypeError "Incomplete pair")))
  (let (kss (get#(slice -2 None -2) pairs)
        ts (get#(slice None None -2) pairs))
    `((op#getitem (@ ,@(map X#`&#,X ts) &#,default)
                  (.get ,(dict chain#(i#starmap (lambda (i ks)
                                                  (map X#(@ X i) ks))
                                                (enumerate kss)))
                        ,key
                        -1)))))

(defmacro _spy e
  `(let ($#e ,e)
     (print (pprint..pformat ',e : sort_dicts 0)
            "=>"
            (repr $#e)
            : file sys..stderr)
     $#e))

(defmacro spy\# e
  "``spy#`` Print e => its value to stderr. Return the value."
  `(hissp.._macro_._spy ,e))

(defmacro time\# e
  "``time#`` Print ms elapsed running e to stderr. Return its value."
  `(let ($#time time..time_ns)
     (let-from ($#start $#val $#end) (@ ($#time) ,e ($#time))
       (print "time# ran"
              (pprint..pformat ',e : sort_dicts 0)
              "in"
              (op#truediv (op#sub $#end $#start)
                          (decimal..Decimal 1e6))
              "ms"
              : file sys..stderr)
       $#val)))

(defmacro ensure (e predicate : :* args)
  "Anaphoric. Raises `AssertionError` `unless` (-> e predicate).

  Additional arguments are evaluated in a context where ``it`` refers
  to the result of e. These (if any) are passed to the `AssertionError`.

  Expansion is simply ``e`` when `__debug__` is off.
  "
  (if-else __debug__
    `(let (,'it ,e)
       (unless (-> ,'it ,predicate)
         (throw (AssertionError ,@args)))
       ,'it)
    e))

(defmacro \[\# e
  "``[#`` 'subscript' Injection. Python's subscription operator.

  Creates a function from the Python expression ``e`` prepended with
  the argument and a ``[``.

  .. code-block:: Lissp

     #> ([#1][::2] '(foo bar))
     >>> (lambda _QzNo76_G:(_QzNo76_G[1][::2]))(
     ...   ('foo',
     ...    'bar',))
     'br'

  See also: `get#<getQzHASH_>`, `-><Qz_QzGT_>`, `slice`.
  "
  "``subscript`` Injection. Python's subscription operator."
  `(lambda ($#G) ,(.format "({}[{})" '$#G (hissp..demunge e))))
