#! Transpiler should ignore the shebang line!
;; Copyright 2019, 2020 Matthew Egan Odendahl
;; SPDX-License-Identifier: Apache-2.0

(hissp.basic.._macro_.alias * hissp.basic.._macro_)

(*#define enlist
  (lambda (: :* a) (list a)))

(*#defmacro tqs ()
  `(enlist 'enlist))

(*#defmacro tqs2 ()
  "test qualified symbol, with docstring"
  `(enlist 'enlist))

(*#defmacro nil () None)

(*#deftype TestBasic (unittest..TestCase)
  test_same_gensym
  (lambda (self)
    (self.assertEqual : :* `($#test $#test)))

  test_qualified_symbol
  (lambda (self)
    (self.assertEqual (tqs)
                      ['tests.test_basic..enlist']))

  test_none_doc
  (lambda (self)
    (self.assertIsNone _macro_.tqs.__doc__))

  test_qualified_symbol2
  (lambda (self)
    (self.assertEqual (tqs2)
                      ['tests.test_basic..enlist']))

  test_doc
  (lambda (self)
    (self.assertEqual _macro_.tqs2.__doc__ "test qualified symbol, with docstring"))

  test_expand_none
  (lambda (self)
    (self.assertIsNone (nil)))

  test_let
  (lambda (self)
    (*#let (x 1
            y 2)
      (self.assertEqual x 1)
      (self.assertEqual y 2)))

  test_doto
  (lambda (self)
    (self.assertEqual (*#doto []
                        (.append 3)
                        (.extend [1,2])
                        (.sort))
                      [1,2,3]))

  test_if-else
  (lambda (self)
    (self.assertEqual (*#if-else False :yes :no) :no)
    (self.assertEqual (*#if-else True :yes :no) :yes)
    (*#let (xs [])
      (*#if-else False
               (.append xs :yes)
               (.append xs :no))
      (*#if-else True
               (.append xs :yes)
               (.append xs :no))
      (self.assertEqual xs [':no',':yes'])))

  test_cond
  (lambda (self)
    (*#let (xs [])
      (.append xs (*#cond))
      (*#cond False (.append xs :oops))
      (*#cond :else (.append xs 1))
      (*#cond False (.append xs :oops)
              :else (.append xs 2))
      (*#cond True (.append xs 3)
              :else (.append xs :oops))
      (*#cond
        False (.append xs :oops)
        0 (.append xs :oops)
        True (.append xs 4)
        () (.append xs :oops))
      (self.assertEqual xs (enlist () 1 2 3 4))))

  test_any-for
  (lambda (self)
    (*#let (xs [])
      (*#any-for i (range 1 10)
        (.append xs i)
        (operator..not_ (operator..mod i 7)))
      (self.assertEqual xs (enlist 1 2 3 4 5 6 7))))

  test_&&
  (lambda (self)
    (*#let (xs [])
      (*#doto xs
        (.append (*#&&))
        (.append (*#&& 0))
        (.append (*#&& 1))
        (.append (*#&& 0 (.append xs :oops)))
        (.append (*#&& 1 (.append xs 2)))
        (.append (*#&& True
                       (.append xs 3)
                       (.append xs :oops)))
        (.append (*#&& True
                       (*#progn (.append xs 4)
                                :oops)
                       (.append xs 5)))
        (.append (*#&& 1 2 (*#progn (.append xs 6) 7))))
      (self.assertEqual [True,0,1,0,2,None,3,None,4,5,None,6,7]
                        xs)))

  test_||
  (lambda (self)
    (*#let (xs [])
      (*#doto xs
        (.append (*#||))
        (.append (*#|| 0))
        (.append (*#|| 1))
        (.append (*#|| 2 (.append xs :oops)))
        (.append (*#|| 0 (.append xs 3)))
        (.append (*#|| 0 (.append xs 5) 6)))
      (self.assertEqual (enlist () 0 1 2 3 None 5 6)
                        xs)))

  test_progn
  (lambda (self)
    (self.assertEqual (*#let (xs [])
                        (*#progn
                          (.append xs 1)
                          (.extend xs "bc")
                          xs))
                      [1,'b','c']))

  test_prog1
  (lambda (self)
    (*#let (xs [])
      (.append xs (*#prog1 3
                    (.append xs 1)
                    (.append xs 2)))
      (self.assertEqual [1,2,3] xs)))

  test_attach
  (lambda (self)
    (*#let (ns (types..SimpleNamespace)
            x 1
            y 2
            z 3)
      (*#attach ns x y z : p 4  q 5  r 6)
      (self.assertEqual (types..SimpleNamespace : x 1  y 2  z 3  p 4  q 5  r 6)
                        ns)))

  test_when
  (lambda (self)
    (*#let (xs [])
      (*#when 1
        (.append xs 1)
        (.append xs 2))
      (*#when 0
        (.append xs :oops)
        (.append xs :oops))
      (self.assertEqual [1,2] xs)))

  test_unless
  (lambda (self)
    (*#let (xs [])
      (*#unless 0
        (.append xs 1)
        (.append xs 2))
      (*#unless 1
        (.append xs :oops)
        (.append xs :oops))
      (self.assertEqual [1,2] xs)))

  test_->
  (lambda (self)
    (self.assertEqual (*#-> "-x-" (.replace "x" "y") (.strip "-") (.upper))
                      "Y"))

  test_->>
  (lambda (self)
    (self.assertEqual (*#->> (range 3)
                             (map (lambda (x) (operator..mul x x)))
                             (filter (lambda (x) ; even?
                                       (operator..eq 0 (operator..mod x 2))))
                             (list))
                      [0,4]))

  test_prelude
  (lambda (self)
    (*#let (ns {})
      (*#prelude ns)
      (self.assertEqual (set operator..__all__)
                        (.intersection (set operator..__all__)
                                       (.keys ns)))
      ;; Asserts everything public in itertools is in ns.
      (*#let (members (set (itertools..filterfalse (lambda x (.startswith x "_"))
                                                   (dir itertools.))))
        (self.assertEqual members (.intersection members (.keys ns))))
      (self.assertIn '_macro_ ns)
      (self.assertEqual (set (dir hissp.basic.._macro_))
                        (.keys (vars (.__getitem__ ns '_macro_))))))

  test_string_newline
  (lambda (self)
    (self.assertEqual #"\
foo\
bar\nbaz"
                  "foobar
baz")
    (self.assertEqual "

foo
bar
"
                  #"\n\nfoo\nbar\n"))

  test_string_reader_macro
  (lambda (self)
    (self.assertEqual fractions..Fraction#.#"1/3"
                      .#(fractions..Fraction 1 3))))
